[{"content":"In a recent webinar, I dived deep into the seamless integration of Sitecore XM Cloud and Next.js Static Site Generation (SSG) to not only unlock efficient and personalized user experiences but also mitigate the downsides associated with server-side rendering. This blog post distills the key insights from the webinar, shedding light on the benefits of SSG and the pitfalls of relying solely on server-side rendering, especially in scenarios involving Sitecore XM Cloud\u0026rsquo;s Connected and Disconnected modes.\nThe Pitfalls of Server-Side Rendering In many applications dealing with Sitecore XM Cloud, the need for Connected and Disconnected modes is a common reality. In Disconnected mode, numerous GraphQL calls to each component, along with integrations with various vendors, may result in a significant overhead. The traditional server-side rendering approach necessitates repeating all these requests on every page request, leading to resource-intensive operations and potentially hindering overall performance.\nThe Power of Internal URL Rewriting To address these challenges, the webinar emphasized the innovative approach of internal URL rewriting within the Next.js middleware. By leveraging this technique, teams can achieve Static Site Generation (SSG) and still deliver unique and personalized output for each user, without the resource-intensive nature of server-side rendering.\nFile System Structure Evolution A significant structural change in the file system route enhances this approach. The root file, previously located at \u0026ldquo;src\\pages\\[[\u0026hellip;path]].tsx,\u0026rdquo; has been strategically relocated to \u0026ldquo;\\src\\pages[country][username][[\u0026hellip;path]].tsx.\u0026rdquo; This shift optimizes the organization of dynamic content and supports the personalization goals of individual user sessions.\nExample Code Revisited: import type { NextRequest, NextFetchEvent } from \u0026#39;next/server\u0026#39; import { NextResponse } from \u0026#39;next/server\u0026#39; import middleware from \u0026#39;lib/middleware\u0026#39; const isHTMLDocument = (req: NextRequest): boolean =\u0026gt; { return req.headers.get(\u0026#39;accept\u0026#39;)?.toLowerCase().includes(\u0026#39;text/html\u0026#39;) ?? false } export const rewrite = (req: NextRequest) =\u0026gt; { const url = req.nextUrl.clone() const cookie = req.cookies.get(\u0026#39;next.session.user\u0026#39;) const country = req.geo?.country?.toLowerCase() ?? \u0026#39;global\u0026#39; const username = cookie?.value ?? \u0026#39;anonymous\u0026#39; let pathname = \u0026#39;\u0026#39; pathname += `/${country}` pathname += `/${username}` pathname += `/${url.pathname}` url.pathname = pathname.replace(/\\/+/gi, \u0026#39;/\u0026#39;) // Enable per-session caching for \u0026#34;getStaticProps\u0026#34;. return NextResponse.rewrite(url) } export const config = { matcher: [\u0026#39;/\u0026#39;, \u0026#39;/((?!api/|_next/|sitecore/api/|-/|healthz).*)\u0026#39;], } export default async function handler(req: NextRequest, event: NextFetchEvent) { const res = await middleware(req, event) if (isHTMLDocument(req)) { return rewrite(req) } return res } The Advantages of Next.js SSG: Resource-Efficiency: By transitioning to Next.js SSG, teams can significantly reduce resource consumption, especially in scenarios involving Connected and Disconnected modes in Sitecore XM Cloud.\nPersonalization without Overhead: Achieve personalized output for each user session without the need for repeated GraphQL calls and integrations on every page request, optimizing both performance and user experience.\nClosing Thoughts While personalization is a crucial aspect of modern web applications, the webinar emphasized the need to carefully consider the downsides of server-side rendering, especially in resource-intensive scenarios. The innovative use of internal URL rewriting within the Next.js middleware emerges as a robust solution, enabling Static Site Generation and personalized content delivery without compromising performance.\nFor a more in-depth example to explore the implementation, please refer to the source code available in this Github repository.\n","permalink":"https://andrelom.github.io/endless/posts/personalization-case-nextjs-static-site-generation-sitecore-xm-cloud/","summary":"In a recent webinar, I dived deep into the seamless integration of Sitecore XM Cloud and Next.js Static Site Generation (SSG) to not only unlock efficient and personalized user experiences but also mitigate the downsides associated with server-side rendering. This blog post distills the key insights from the webinar, shedding light on the benefits of SSG and the pitfalls of relying solely on server-side rendering, especially in scenarios involving Sitecore XM Cloud\u0026rsquo;s Connected and Disconnected modes.","title":"Navigating the Personalization Landscape: A Case for Next.js Static Site Generation with Sitecore XM Cloud"},{"content":"Efficient and secure connections between different platforms are crucial in the ever-evolving web development landscape. One such scenario is integrating Sitecore Content Hub with Next.js applications.\nBy utilizing Next.js and implementing reverse proxy calls, developers can optimize communication while safeguarding sensitive information. In this blog post, we\u0026rsquo;ll explore the benefits of reverse proxy calls and how they enhance security and API protection by concealing the Content Hub endpoint and API token.\nBenefits of Reverse Proxy Calls When integrating Next.js with Sitecore Content Hub, reverse proxy calls offer an additional layer of security. By routing requests through a reverse proxy server, the Content Hub endpoint remains shielded from direct exposure.\nHidden Endpoint and API Token Reverse proxy calls also ensure the concealment of sensitive information, such as the Content Hub endpoint and API token, from client-side code. Rather than making direct requests to the Content Hub API, all requests are directed to the reverse proxy server. This approach minimizes the risk of exposing the endpoint and API token to potential threats, providing heightened protection for sensitive information.\nImplementation To get started, we need to install the \u0026ldquo;http-proxy-middleware\u0026rdquo; npm module. Open your terminal and run the following command:\nyarn add http-proxy-middleware Updating the Client File Next, we\u0026rsquo;ll update the client file \u0026ldquo;sitecorecloud.ts\u0026rdquo; with the following code:\nimport { createApolloClient } from \u0026#39;endless-lib/apollo\u0026#39; const sitecorecloud = createApolloClient({ uri: process.env.APOLLO_SITECORECLOUD_URI ?? \u0026#39;/api/proxy/sitecorecloud\u0026#39;, headers: { \u0026#39;X-GQL-Token\u0026#39;: process.env.APOLLO_SITECORECLOUD_TOKEN ?? \u0026#39;\u0026#39;, }, }) export default sitecorecloud As you can observe, when executing this call on the server, we direct it to the original endpoint. However, if we\u0026rsquo;re not on the server, we use the reverse proxy endpoint instead. Additionally, please note that environment variables which don\u0026rsquo;t begin with \u0026ldquo;NEXT_PUBLIC_\u0026rdquo; will not be accessible on the client side.\nMake sure to replace \u0026ldquo;endless-lib/apollo\u0026rdquo; with the appropriate import for your specific setup.\nCreating the API Endpoint (Reverse Proxy) Now, let\u0026rsquo;s create the API endpoint with the following code:\n// File: pages/api/proxy/sitecorecloud/[[...sitecorecloud]].api.ts import type { NextApiRequest, NextApiResponse } from \u0026#39;next\u0026#39; import { createProxyMiddleware } from \u0026#39;http-proxy-middleware\u0026#39; const proxy = createProxyMiddleware({ secure: false, changeOrigin: true, target: process.env.APOLLO_SITECORECLOUD_URI, pathRewrite: { \u0026#39;/api/proxy/sitecorecloud\u0026#39;: \u0026#39;\u0026#39;, }, }) as (req: NextApiRequest, res: NextApiResponse) =\u0026gt; void export const config = { api: { bodyParser: false, externalResolver: true, }, } export default async function handler(req: NextApiRequest, res: NextApiResponse) { const header = \u0026#39;X-GQL-Token\u0026#39;.toLowerCase() // Since the value of the environment variable is not public // to the client, this header value will be undefined. // Therefore, we set it before sending the request. req.headers[header] = process.env.APOLLO_SITECORECLOUD_TOKEN proxy(req, res) } This file sets up a reverse proxy using the http-proxy-middleware module. It forwards requests to the specified target (\u0026ldquo;process.env.APOLLO_SITECORECLOUD_URI\u0026rdquo;) while rewriting the path to remove the proxy part (\u0026quot;/api/proxy/sitecorecloud\u0026quot;). The \u0026ldquo;X-GQL-Token\u0026rdquo; header is added to the request using the value from the environment variable \u0026ldquo;APOLLO_SITECORECLOUD_TOKEN\u0026rdquo;.\nRemember to adjust the code to match your specific environment and requirements.\nConclusion Reverse proxy calls streamline the integration of Sitecore Content Hub with Next.js, enhancing security and simplifying the process.\nThe HTTP Proxy Middleware simplifies the implementation of reverse proxy functionality in Next.js applications by handling low-level configurations. It acts as an intermediary, allowing direct calls to the original endpoint on the back-end while providing security and abstraction for the client-side application.\nBy leveraging reverse proxy calls and the capabilities of Next.js and the HTTP Proxy Middleware, developers can establish a seamless integration between Sitecore Content Hub and Next.js, ensuring secure and optimized content management and delivery.\n","permalink":"https://andrelom.github.io/endless/posts/seamless-integration-of-sitecore-content-hub-with-nextjs-using-reverse-proxy-calls/","summary":"Efficient and secure connections between different platforms are crucial in the ever-evolving web development landscape. One such scenario is integrating Sitecore Content Hub with Next.js applications.\nBy utilizing Next.js and implementing reverse proxy calls, developers can optimize communication while safeguarding sensitive information. In this blog post, we\u0026rsquo;ll explore the benefits of reverse proxy calls and how they enhance security and API protection by concealing the Content Hub endpoint and API token.","title":"Seamless Integration of Sitecore Content Hub With Next.js Using Reverse Proxy Calls"},{"content":"In some projects, we are faced with activities that lead us to create new pipelines or even a new layout service for applications using Sitecore JSS. In these situations, it is common to need to access the site\u0026rsquo;s context item.\nThe problem is that many times these pipelines or layout services are used either for API calls (a.k.a. \u0026ldquo;/sitecore/api/layout/render/jss\u0026rdquo;) or GraphQL (a.k.a. \u0026ldquo;/sitecore/api/graph/edge\u0026rdquo;). In the execution context of both situations, access to the context item alternates, and in API-type calls, the object will not point to the site item we expect.\nEndpoints:\nJSS API: /sitecore/api/layout/render/jss?sc_apikey={GUID}\u0026amp;item={GUID} JSS GraphQL: /sitecore/api/graph/edge?sc_apikey={GUID} To solve this problem, we can create a helper that will act whether the call is made through the JSS or GraphQL API, and will return the site\u0026rsquo;s relative context item for both situations.\nGet to Work First, we need to ensure that we will have access to the site item from any content item, that way, regardless of which item we get from the context, we will know which site it belongs to.\npublic static Item GetRelativeSite(this Item item) { var site = SiteContextFactory.Sites .Where(entry =\u0026gt; !string.IsNullOrWhiteSpace(entry.RootPath) \u0026amp;\u0026amp; item.Paths.Path.StartsWith(entry.RootPath, StringComparison.OrdinalIgnoreCase)) .OrderByDescending(entry =\u0026gt; entry.RootPath.Length) .FirstOrDefault(); if (site == null) { return null; } return Utilities.GetItem(site.RootPath); } With this method available above (which, by the way, can be useful in several other situations), we can create the solution that will help us access the site item.\nNow we can do a very simple operation. When JSS calls are made via the standard API, the home item ID is sent via the URL Query, as the one we usually use (\u0026ldquo;Sitecore.Context.Item\u0026rdquo;) will not point to the site item we expect.\nIf this value is available in the HTTP Context URL, we can access the home item, otherwise (the \u0026ldquo;item\u0026rdquo; parameter is not in the URL Query) we will try to access the context item (indicating that we are likely in a GraphQL call).\nThe solution presented below has been simplified to make it easier to read and understand. Once we have the home item, we just need to access the parent item to get the site.\npublic static Item GetContextHomeItem() { // If the request came from \u0026#34;/sitecore/api/layout/render/jss\u0026#34;, we get it from the HTTP context URL query, // otherwise (a.k.a. \u0026#34;/sitecore/api/graph/edge\u0026#34;), we get it from the Sitecore Context Item. const string key = \u0026#34;item\u0026#34;; var url = HttpContext.Current.Request.Url; var uid = HttpUtility.ParseQueryString(url.Query).Get(key); if (uid?.IsValidGuid() ?? false) { return Utilities.GetItem(uid); } var site = Context.Item?.GetRelativeSite(); if (site == null) { return null; } return Utilities.GetItem($\u0026#34;{site.Paths.Path}/Home\u0026#34;); } Conclusion The main idea of this article is not just to present a proposed solution, which by the way can be improved in many aspects, but to help us remember that when dealing with JSS, we are possibly dealing with two fronts, with HTTP requests being made directly to the standard API and others made via GraphQL, and keeping an eye on these details can help us to create creative and reliable projects.\nYou can access the complete source code used in this article through the GitHub repository.\n","permalink":"https://andrelom.github.io/endless/posts/get-site-context-item-in-jss-api-and-graphql-calls/","summary":"In some projects, we are faced with activities that lead us to create new pipelines or even a new layout service for applications using Sitecore JSS. In these situations, it is common to need to access the site\u0026rsquo;s context item.\nThe problem is that many times these pipelines or layout services are used either for API calls (a.k.a. \u0026ldquo;/sitecore/api/layout/render/jss\u0026rdquo;) or GraphQL (a.k.a. \u0026ldquo;/sitecore/api/graph/edge\u0026rdquo;). In the execution context of both situations, access to the context item alternates, and in API-type calls, the object will not point to the site item we expect.","title":"Get site context item in JSS API and GraphQL calls"}]