<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Get site context item in JSS API and GraphQL calls | André Moraes</title>
<meta name=keywords content="Sitecore,Helpers,JSS,GraphQL"><meta name=description content="How to get corresponding site context item in JSS API and GraphQL calls."><meta name=author content="André Moraes"><link rel=canonical href=https://andrelom.github.io/endless/posts/get-site-context-item-in-jss-api-and-graphql-calls/><link crossorigin=anonymous href=/endless/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/endless/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://andrelom.github.io/endless/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andrelom.github.io/endless/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andrelom.github.io/endless/favicon-32x32.png><link rel=apple-touch-icon href=https://andrelom.github.io/endless/apple-touch-icon.png><link rel=mask-icon href=https://andrelom.github.io/endless/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Get site context item in JSS API and GraphQL calls"><meta property="og:description" content="How to get corresponding site context item in JSS API and GraphQL calls."><meta property="og:type" content="article"><meta property="og:url" content="https://andrelom.github.io/endless/posts/get-site-context-item-in-jss-api-and-graphql-calls/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-01-28T21:16:50-03:00"><meta property="article:modified_time" content="2023-01-28T21:16:50-03:00"><meta property="og:site_name" content="Endless"><meta name=twitter:card content="summary"><meta name=twitter:title content="Get site context item in JSS API and GraphQL calls"><meta name=twitter:description content="How to get corresponding site context item in JSS API and GraphQL calls."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://andrelom.github.io/endless/posts/"},{"@type":"ListItem","position":2,"name":"Get site context item in JSS API and GraphQL calls","item":"https://andrelom.github.io/endless/posts/get-site-context-item-in-jss-api-and-graphql-calls/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Get site context item in JSS API and GraphQL calls","name":"Get site context item in JSS API and GraphQL calls","description":"How to get corresponding site context item in JSS API and GraphQL calls.","keywords":["Sitecore","Helpers","JSS","GraphQL"],"articleBody":"In some projects, we are faced with activities that lead us to create new pipelines or even a new layout service for applications using Sitecore JSS. In these situations, it is common to need to access the site’s context item.\nThe problem is that many times these pipelines or layout services are used either for API calls (a.k.a. “/sitecore/api/layout/render/jss”) or GraphQL (a.k.a. “/sitecore/api/graph/edge”). In the execution context of both situations, access to the context item alternates, and in API-type calls, the object will not point to the site item we expect.\nEndpoints:\nJSS API: /sitecore/api/layout/render/jss?sc_apikey={GUID}\u0026item={GUID} JSS GraphQL: /sitecore/api/graph/edge?sc_apikey={GUID} To solve this problem, we can create a helper that will act whether the call is made through the JSS or GraphQL API, and will return the site’s relative context item for both situations.\nGet to Work First, we need to ensure that we will have access to the site item from any content item, that way, regardless of which item we get from the context, we will know which site it belongs to.\npublic static Item GetRelativeSite(this Item item) { var site = SiteContextFactory.Sites .Where(entry =\u003e !string.IsNullOrWhiteSpace(entry.RootPath) \u0026\u0026 item.Paths.Path.StartsWith(entry.RootPath, StringComparison.OrdinalIgnoreCase)) .OrderByDescending(entry =\u003e entry.RootPath.Length) .FirstOrDefault(); if (site == null) { return null; } return Utilities.GetItem(site.RootPath); } With this method available above (which, by the way, can be useful in several other situations), we can create the solution that will help us access the site item.\nNow we can do a very simple operation. When JSS calls are made via the standard API, the home item ID is sent via the URL Query, as the one we usually use (“Sitecore.Context.Item”) will not point to the site item we expect.\nIf this value is available in the HTTP Context URL, we can access the home item, otherwise (the “item” parameter is not in the URL Query) we will try to access the context item (indicating that we are likely in a GraphQL call).\nThe solution presented below has been simplified to make it easier to read and understand. Once we have the home item, we just need to access the parent item to get the site.\npublic static Item GetContextHomeItem() { // If the request came from \"/sitecore/api/layout/render/jss\", we get it from the HTTP context URL query, // otherwise (a.k.a. \"/sitecore/api/graph/edge\"), we get it from the Sitecore Context Item. const string key = \"item\"; var url = HttpContext.Current.Request.Url; var uid = HttpUtility.ParseQueryString(url.Query).Get(key); if (uid?.IsValidGuid() ?? false) { return Utilities.GetItem(uid); } var site = Context.Item?.GetRelativeSite(); if (site == null) { return null; } return Utilities.GetItem($\"{site.Paths.Path}/Home\"); } Conclusion The main idea of this article is not just to present a proposed solution, which by the way can be improved in many aspects, but to help us remember that when dealing with JSS, we are possibly dealing with two fronts, with HTTP requests being made directly to the standard API and others made via GraphQL, and keeping an eye on these details can help us to create creative and reliable projects.\nYou can access the complete source code used in this article through the GitHub repository.\n","wordCount":"509","inLanguage":"en","datePublished":"2023-01-28T21:16:50-03:00","dateModified":"2023-01-28T21:16:50-03:00","author":{"@type":"Person","name":"André Moraes"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://andrelom.github.io/endless/posts/get-site-context-item-in-jss-api-and-graphql-calls/"},"publisher":{"@type":"Organization","name":"André Moraes","logo":{"@type":"ImageObject","url":"https://andrelom.github.io/endless/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andrelom.github.io/endless/ accesskey=h title="André Moraes (Alt + H)">André Moraes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://andrelom.github.io/endless/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://andrelom.github.io/endless/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://andrelom.github.io/endless/archives/ title=Archives><span>Archives</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Get site context item in JSS API and GraphQL calls</h1><div class=post-description>How to get corresponding site context item in JSS API and GraphQL calls.</div><div class=post-meta>January 28, 2023 André Moraes</div></header><div class=post-content><p>In some projects, we are faced with activities that lead us to create new pipelines or even a new layout service for applications using Sitecore JSS. In these situations, it is common to need to access the site&rsquo;s context item.</p><p>The problem is that many times these pipelines or layout services are used either for API calls (a.k.a. &ldquo;/sitecore/api/layout/render/jss&rdquo;) or GraphQL (a.k.a. &ldquo;/sitecore/api/graph/edge&rdquo;). In the execution context of both situations, access to the context item alternates, and in API-type calls, the object will not point to the site item we expect.</p><p>Endpoints:</p><ul><li>JSS API: /sitecore/api/layout/render/jss?sc_apikey={GUID}&amp;item={GUID}</li><li>JSS GraphQL: /sitecore/api/graph/edge?sc_apikey={GUID}</li></ul><p>To solve this problem, we can create a helper that will act whether the call is made through the JSS or GraphQL API, and will return the site&rsquo;s relative context item for both situations.</p><h2 id=get-to-work>Get to Work<a hidden class=anchor aria-hidden=true href=#get-to-work>#</a></h2><p>First, we need to ensure that we will have access to the site item from any content item, that way, regardless of which item we get from the context, we will know which site it belongs to.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> Item GetRelativeSite(<span style=color:#66d9ef>this</span> Item item)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> site = SiteContextFactory.Sites
</span></span><span style=display:flex><span>        .Where(entry =&gt; !<span style=color:#66d9ef>string</span>.IsNullOrWhiteSpace(entry.RootPath) &amp;&amp; item.Paths.Path.StartsWith(entry.RootPath, StringComparison.OrdinalIgnoreCase))
</span></span><span style=display:flex><span>        .OrderByDescending(entry =&gt; entry.RootPath.Length)
</span></span><span style=display:flex><span>        .FirstOrDefault();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (site == <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> Utilities.GetItem(site.RootPath);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>With this method available above (which, by the way, can be useful in several other situations), we can create the solution that will help us access the site item.</p><p>Now we can do a very simple operation. When JSS calls are made via the standard API, the home item ID is sent via the URL Query, as the one we usually use (&ldquo;Sitecore.Context.Item&rdquo;) will not point to the site item we expect.</p><p>If this value is available in the HTTP Context URL, we can access the home item, otherwise (the &ldquo;item&rdquo; parameter is not in the URL Query) we will try to access the context item (indicating that we are likely in a GraphQL call).</p><p>The solution presented below has been simplified to make it easier to read and understand. Once we have the home item, we just need to access the parent item to get the site.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> Item GetContextHomeItem()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// If the request came from &#34;/sitecore/api/layout/render/jss&#34;, we get it from the HTTP context URL query,</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// otherwise (a.k.a. &#34;/sitecore/api/graph/edge&#34;), we get it from the Sitecore Context Item.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>string</span> key = <span style=color:#e6db74>&#34;item&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> url = HttpContext.Current.Request.Url;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> uid = HttpUtility.ParseQueryString(url.Query).Get(key);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (uid?.IsValidGuid() ?? <span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> Utilities.GetItem(uid);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> site = Context.Item?.GetRelativeSite();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (site == <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> Utilities.GetItem(<span style=color:#e6db74>$&#34;{site.Paths.Path}/Home&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>The main idea of this article is not just to present a proposed solution, which by the way can be improved in many aspects, but to help us remember that when dealing with JSS, we are possibly dealing with two fronts, with HTTP requests being made directly to the standard API and others made via GraphQL, and keeping an eye on these details can help us to create creative and reliable projects.</p><blockquote><p>You can access the complete source code used in this article through the <a href=https://github.com/andrelom/endless/blob/c517bdfdc6113a1dde061df5ab8e02ba926da51f/src/Foundation/Endless.Foundation.Core/Utilities.cs#L74>GitHub repository</a>.</p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://andrelom.github.io/endless/tags/sitecore/>Sitecore</a></li><li><a href=https://andrelom.github.io/endless/tags/helpers/>Helpers</a></li><li><a href=https://andrelom.github.io/endless/tags/jss/>JSS</a></li><li><a href=https://andrelom.github.io/endless/tags/graphql/>GraphQL</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://andrelom.github.io/endless/>André Moraes</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>